Function:
  Enabled For RDMLX:  Yes

  Source: |
    Function Options(*DIRECT) Rcv_List(#wLKData #wLRet)
    
    * ******************************************************************************************************
    * Test Case Description
    *
    * Testing the OPTIONS *STARTKEY *ENDWHERE *ENDWHERESQL
    *
    *
    * ******************************************************************************************************
    
    * Unique Key Data.
    Def_List Name(#wLKData) Fields(#VTF_KEY1 #VTF_KEY2 #VTF_KEY3) Type(*WORKING) Entrys(1)
    
    * Return messages.
    Def_List Name(#wLRet) Fields(#BIFMSGC #BIFMSG1 #BIFMSG2) Counter(#BIFMSGCNT) Type(*WORKING) Entrys(*MAX)
    
    * List Of Test data.
    Define Field(#LF_Test_Data) Reffld(#BIFN0702A)
    Define Field(#LF_Test_Data_Count) Reffld(#Std_Count)
    Define Field(#LF_Test_Key_Count) Reffld(#Std_Count)
    Def_List Name(#wLTestData) Fields(#LF_Test_Data) Counter(#LF_Test_Data_Count) Type(*WORKING) Entrys(*MAX)
    Def_List Name(#wLTestKey) Fields(#LF_Test_Data #LF_TraceData) Counter(#LF_Test_Key_Count) Type(*WORKING) Entrys(*MAX)
    
    Define Field(#LF_rc) Reffld(#BIFA002A) Default(OK)
    Define Field(#LF_i) Reffld(#Std_Count)
    Define Field(#LF_j) Reffld(#Std_Count)
    Define Field(#LF_Total_Errors) Reffld(#Std_Count)
    Define Field(#LF_Total_Warnings) Reffld(#Std_Count)
    Define Field(#LF_Execution_Type) Reffld(#Std_Alpha)
    Define Field(#LF_Remote_Platform) Reffld(#BIFA001A)
    
    Define Field(#LF_Operation_Name) Reffld(#BIFMSG1)
    Define Field(#LF_TraceData) Reffld(#BIFB001E) Default(False)
    Define Field(#LF_View_Type) Reffld(#BIFMSG1)
    Define Field(#LF_Test_Result_Generic_Integer2_Count) Reffld(#Std_Count)
    Define Field(#LF_Test_Result_LI0043DI2) Reffld(#STD_COUNT)
    Def_List Name(#wLTestResultGenericInteger2) Fields(#BIFINT2S) Counter(#LF_Test_Result_Generic_Integer2_Count) Type(*WORKING) Entrys(*MAX)
    Def_List Name(#wLTestResultGenericInteger2Backwards) Fields(#BIFINT2S) Counter(#LF_Test_Result_Generic_Integer2_Count) Type(*WORKING) Entrys(*MAX)
    Def_List Name(#wLTestResultGenericInteger2ForwardsDescending) Fields(#BIFINT2S) Counter(#LF_Test_Result_Generic_Integer2_Count) Type(*WORKING) Entrys(*MAX)
    
    * Start testing.
    Clr_List Named(#wLRet)
    #Com_Owner.mthAdd_Msg( OK *Function ('Start - ' + *Function_Desc) )
    
    Get_Entry Number(1) From_List(#wLKData)
    #LF_Execution_Type := #VTF_KEY1
    #LF_Remote_Platform := #VTF_KEY2
    
    * Debug code to only run on a particular platform
    * Local Windows execution = *BLANKS
    If (#LF_Remote_Platform *NE I)
    * Return
    Endif
    
    * For debug. Don't run this function on IBM i. Saves time when tracing and need to look at the SuperServer IO results from IBM i
    * SuperServer IO to IBM i has #LF_Remote_Platform *EQ I and *OSAPI *EQ WIN32
    If (*OSAPI *EQ IBMI)
    * Return
    Endif
    
    * SETUP THE TEST DATA.
    Execute Subroutine(AddTestData)
    
    * DELETE / INSERT TEST DATA.
    #Com_Owner.mthDoDelete( #LF_rc )
    #Com_Owner.mthDoInsert( #LF_rc )
    
    * SEARCH TEST.
    #Com_Owner.mthDoSearch( #LF_rc )
    
    #Com_Owner.mthAdd_Msg( OK *Function 'End' )
    Use Builtin(CLR_MESSAGES)
    
    Return
    
    *
    * Add Test Data.
    *
    Subroutine Name(AddTestData)
    Define Field(#LF_String) Reffld(#BIFC256A)
    
    Clr_List Named(#wLTestData)
    * Generate numbers from 100.00 to 119.90 in 0.06 increments
    Begin_Loop Using(#LF_i) From(100) To(119)
    Begin_Loop Using(#LF_j) From(0) To(90) Step(6)
    #LF_String := #LF_i.asString + '.' + #LF_j.asString
    #LF_Test_Data := #LF_String.asNumber
    Add_Entry To_List(#wLTestData)
    End_Loop
    End_Loop
    
    * Generate numbers from -100.00 to -119.90 in 0.06 increments
    Begin_Loop Using(#LF_i) From(-100) To(-119) Step(-1)
    Begin_Loop Using(#LF_j) From(0) To(90) Step(6)
    #LF_String := #LF_i.asString + '.' + #LF_j.asString
    #LF_Test_Data := #LF_String.asNumber
    Add_Entry To_List(#wLTestData)
    End_Loop
    End_Loop
    
    * Keys with trailing zeroes may return multiple rows when using Generic(*YES)
    Clr_List Named(#wLTestResultGenericInteger2)
    Clr_List Named(#wLTestResultGenericInteger2Backwards)
    Clr_List Named(#wLTestResultGenericInteger2ForwardsDescending)
    
    * *****************************************************************************
    * Search <1>
    * *****************************************************************************
    #LF_Test_Data := 100
    #LF_TraceData := False
    Add_Entry To_List(#wLTestKey)
    
    * Generic Forwards
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2)
    
    * BACKWARDS
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2Backwards)
    
    * FORWARDS DESCENDING
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2ForwardsDescending)
    
    
    * *****************************************************************************
    * Search <2>
    * *****************************************************************************
    #LF_Test_Data := 110
    #LF_TraceData := False
    Add_Entry To_List(#wLTestKey)
    
    * Generic Forwards
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2)
    
    * BACKWARDS
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2Backwards)
    
    * FORWARDS DESCENDING
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2ForwardsDescending)
    
    
    * *****************************************************************************
    * Search <3>
    * *****************************************************************************
    #LF_Test_Data := 111
    #LF_TraceData := False
    Add_Entry To_List(#wLTestKey)
    
    * Generic Forwards
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2)
    
    * BACKWARDS
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2Backwards)
    
    * FORWARDS DESCENDING
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2ForwardsDescending)
    
    * *****************************************************************************
    * Search <4>
    * *****************************************************************************
    #LF_Test_Data := -100
    #LF_TraceData := False
    Add_Entry To_List(#wLTestKey)
    
    * Generic Forwards
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2)
    
    * BACKWARDS
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2Backwards)
    
    * FORWARDS DESCENDING
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2ForwardsDescending)
    
    * *****************************************************************************
    * Search <5>
    * *****************************************************************************
    #LF_Test_Data := -110
    #LF_TraceData := False
    Add_Entry To_List(#wLTestKey)
    
    * Generic Forwards
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2)
    
    * BACKWARDS
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2Backwards)
    
    * FORWARDS DESCENDING
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2ForwardsDescending)
    
    * *****************************************************************************
    * Search <6>
    * *****************************************************************************
    #LF_Test_Data := -111
    #LF_TraceData := False
    Add_Entry To_List(#wLTestKey)
    
    * Generic Forwards
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2)
    
    * BACKWARDS
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2Backwards)
    
    * FORWARDS DESCENDING
    #LF_Test_Result_LI0043DI2 := 0
    Add_Entry To_List(#wLTestResultGenericInteger2ForwardsDescending)
    
    Endroutine
    
    *
    * Delete Data.
    *
    Mthroutine Name(mthDoDelete)
    Define_Map For(*BOTH) Class(#BIFA002A) Name(#this_rc)
    
    #LF_i := 0
    Dowhile Cond(#this_rc = OK)
    Fetch Fields(#BIFC010A) From_File(VTLI0043D) Io_Status(#this_rc) Io_Error(*NEXT) Val_Error(*NEXT)
    If (#this_rc = OK)
    #LF_i += 1
    Delete From_File(VTLI0043D) With_Key(#BIFC010A) Io_Error(*NEXT) Val_Error(*NEXT)
    Endif
    Endwhile
    
    #this_rc := OK
    #Com_Owner.mthAdd_SubMsg( #this_rc 'Delete Data' (#LF_i.AsString + ' set of key records deleted') )
    Endroutine
    
    *
    * Insert Data.
    *
    Mthroutine Name(mthDoInsert)
    Define_Map For(*BOTH) Class(#BIFA002A) Name(#this_rc)
    
    Define Field(#LF_iMod) Reffld(#STD_COUNT)
    
    #BIFC010A := #VTF_KEY1 + #VTF_KEY2 + #VTF_KEY3
    #BIFN0700A := 0
    
    If (#this_rc = OK)
    Begin_Loop Using(#LF_i) To(#LF_Test_Data_Count)
    Get_Entry Number(#LF_i) From_List(#wLTestData)
    #BIFN0700A += 1
    #BIFINT2S := #LF_Test_Data
    Insert Fields(*ALL) To_File(VTLI0043D) Io_Status(#this_rc) Io_Error(*NEXT) Val_Error(*NEXT)
    If (#this_rc *NE OK)
    #this_rc := ER
    Leave
    Endif
    End_Loop
    Endif
    
    #Com_Owner.mthAdd_SubMsg( #this_rc 'Insert Data' (#BIFN0700A.AsString + ' / ' + #LF_Test_Data_Count.AsString + ' records inserted') )
    Endroutine
    
    *
    * Search.
    *
    Mthroutine Name(mthDoSearch)
    Define_Map For(*BOTH) Class(#BIFA002A) Name(#this_rc)
    Endroutine
    
    *
    * mthDoTestResult
    *
    * Requires results (#LF_Test_Result_*) to have been appropriately populated from the Test Result lists
    * And then the actual SELECT results in the #LF_Func_* set of fields
    *
    Mthroutine Name(mthDoTestResult)
    Define_Map For(*INPUT) Class(#BIFMSG1) Name(#this_operation)
    Define_Map For(*BOTH) Class(#BIFA002A) Name(#this_rc)
    Endroutine
    
    * Add a message to the Return Message List.
    Mthroutine Name(mthAdd_Msg)
    Define_Map For(*INPUT) Class(#BIFMSGC) Name(#this_msg_code)
    Define_Map For(*INPUT) Class(#BIFMSG1) Name(#this_msg1)
    Define_Map For(*INPUT) Class(#BIFMSG2) Name(#this_msg2)
    
    #BIFMSGC := #this_msg_code
    #BIFMSG1 := #this_msg1
    #BIFMSG2 := #this_msg2
    Add_Entry To_List(#wLRet)
    Endroutine
    
    * Add a sub message to the Return Message List.
    Mthroutine Name(mthAdd_SubMsg)
    Define_Map For(*INPUT) Class(#BIFMSGC) Name(#this_msg_code)
    Define_Map For(*INPUT) Class(#BIFMSG1) Name(#this_msg1)
    Define_Map For(*INPUT) Class(#BIFMSG2) Name(#this_msg2)
    
    #BIFMSGC := #this_msg_code
    #BIFMSG1 := ' ' + #this_msg1
    #BIFMSG2 := #this_msg2
    Add_Entry To_List(#wLRet)
    Endroutine
    
    * Add a sub message to the Return Message List.
    Mthroutine Name(mthAdd_TraceMsg)
    Define_Map For(*INPUT) Class(#BIFMSGC) Name(#this_msg_code)
    Define_Map For(*INPUT) Class(#BIFMSG1) Name(#this_msg1)
    Define_Map For(*INPUT) Class(#BIFMSG2) Name(#this_msg2)
    
    If (#LF_TraceData)
    #Com_Owner.mthAdd_SubMsg( #this_msg_code #this_msg1 #this_msg2 )
    Endif
    Endroutine
